## An alternative to mainstream encryption for low and mid range machines

### **1. Motivation**

In our era, there is an incredible need for data privacy and publicly accessible encryption algorithms.
Personal information is stolen daily and private communications are sometimes easily intercepted.
In fact, the annual expenses generated by cybercrime damages are expected to rise to $5 trillion
by 2020.

When cyber attacks are at their peak, how could the average computer user transmit a message
to someone else, while minimising the chance of its content being intercepted?
The Cryptographer represents a potential solution to this problem. Widely known encryption
algorithms, such as RSA are completely reliable in the current technological context, provided the
key is large enough. However, they are weak and cannot withstand a brute force attack when the
key length is smaller. The issue an ordinary user faces is that they does not have the computing
power of a bank or a government agency and cannot generate a large key without spending an
unreasonable amount of time on implementation and generating values. Even if some users have
no programming knowledge, they still have the right to private conversations.

### **2. Alice and Bob**
When using the Cryptographer, Alice and Bob will, at first, encrypt their data using ElGamal.
Then, the resulting values will be mapped to valid frequencies and placed in a Waveform Audio
File (wav). Next, more frequencies are added to the file so that it resembles a valid audio file. The
process can be reversed only if the person that has the final file knows the mapping and the private
key.

At first, Alice and Bob agree on a mapping from every digit from 0 to 9 to a frequency with
a binary representation that differs from 0. Each digit must map uniquely to a frequency. When
Alice wants to encrypt a message, she calls the Cryptographer. A pair of keys is generated:
   A relatively large number (that will not lead to an overflow) q is chosen.
   From a cyclic group F(q), an element g is selected
   From the same acyclic group, an element a is selected, such that gcd(a, q) = 1
   The value h = g^a
   A random value y from F(q), such that gcd(y, q) = 1. A new y is usually generated for each
    encryption in order to improve security. Thus, y is called an ephemeral key.

F, h, q and g represent the public key, while a is kept safely as it represents the private key. y
will be transmitted, too as it is required in decryption.

Alice encrypts her message using the private key. Now, we have the first ciphertext, an array
of positive integers. The array is then processed by the audio encoder, which writes in a ’wav’ file
indicated by the user. Therefore, for each digit of each number in the array a frequency is written
in the file, according to the mapping established before. A frequency is represented, in binary, by
two bytes (16 bits). The resulting ciphertext is placed, in order, right after the file header. A
frequency of 0 represents the ending of a number and two consecutive frequencies of 0 mark the
end of the encoded message.

Finally, the obfuscator is called to create an array of values that will be written to the audio file
so that it actually behaves like a ’wav’. The encrypted message will always vary in length, but it
will not be noticed when playing the file, because more than 44 000 samples are played per second
and there are just too few frequencies that actually hide something to be noticed.

Now, Bob has the agreed mapping, the private key and the audio file, and he wants to knows
what Alice has to say to him. He will also call the Cryptographer, but in decryption mode.
Our program will read the ’wav’ file in binary mode, skip the header, and start processing the
frequencies, two bytes at a time. Each value will be mapped to its original digit and an integer will
be created. When a value of 0 is encountered, we save the current integer in an array and start to
generate a new integer. When two consecutive frequencies of 0 are encountered in the binary file,
we stop processing it altogether. Bob now has the first ciphertext.

Next, Bob must reverse the ElGamal encryption in order to reach the original message. To do
this, the Cryptographer calculates h = g
a∗y and divides each integer in the ciphertext by h. The result represent the ASCII values of each 
character in the intial text. Finally, these characters are printed and Bob has now succesfully 
decrypted Alice’s message.

### **3. User Interaction**
When implementing the extension, we tried to design a program with perfect user interaction as we
wanted everyone to be able to use it, not just people who understand programming or cryptography.
Such, the Cryptographer works in two modes: encryption and decryption.
If the ”enc” argument is given, the name of the output file and the one that stores the digits to
frequencies encodings are expected as arguments. Next, the user will be asked to input a message
to encrypt. The ciphertext will then be written in the desired file.
If the ”dec” argument is given, we go into decryption mode: a ’wav’ file and the file that stores
the encodings from digits to frequencies are expected as arguments. The user is then asked to
provide the private key for ElGamal decryption. The message is printed to the standard output
after decoding.
If the number of provided arguments is not the one we expect, or an unexpected argument is
given, instructions are provided in order to help the user.

### **4. Testing**
The program ”testCryptographer.py” was created for testing. We chose Python as it provided
functions that could easily interact with C programs and the standard input and output. Although
Python is generally slower than other programming languages, speed was not of interest here, as
we only cared about the correctness of our algorithm.
Finally, our testing process relied on the fact that the initial message and the string that results
after encryption and decryption must be the same. Thus, we generated a file with random strings of
various lengths and we loaded each string in our Python script. Then we called the Cryptographer
to encode it and to do the decoding, acting as both Alice and Bob. In the end we compared the
initial string and the resulting one. If there were no differences, the Cryptographer behaved as
expected. In the end, we tested our extension on more than 1000 tests. They all passed, indicating
that the Cryptographer was implemented correctly
